<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2017-12-18-js正则替换图片路径" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/18/2017-12-18-js正则替换图片路径/" class="article-date">
  <time datetime="2017-12-18T08:04:06.000Z" itemprop="datePublished">2017-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/18/2017-12-18-js正则替换图片路径/">js正则替换图片路径</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="把图片的相对路径改成绝对路径"><a href="#把图片的相对路径改成绝对路径" class="headerlink" title="把图片的相对路径改成绝对路径"></a>把图片的相对路径改成绝对路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var content = &apos;thisis&lt;img src=&quot;abc.jpg&quot; width=&quot;50&quot; /&gt;&lt;img src=&quot;cde.jpg&quot; /&gt;&apos;;</span><br><span class="line">var originHost=&apos;http://www.baidu.com/&apos;;</span><br><span class="line">content.replace(/&lt;img [^&gt;]*src=[&apos;&quot;]([^&apos;&quot;]+)[^&gt;]*&gt;/gi, function (match, capture) &#123;</span><br><span class="line"> 	// console.log(&apos;capture=&apos;+capture);</span><br><span class="line"> 	// console.log(&apos;match=&apos;+match);</span><br><span class="line">	var tmp =&apos;&apos;;</span><br><span class="line">	var absoluteSrcRegx=/http:/gi.test(capture)||/https:/gi.test(capture)</span><br><span class="line">	if (!absoluteSrcRegx) &#123;</span><br><span class="line">	//    console.log(&apos;===&apos;)</span><br><span class="line">		tmp= match.replace(capture,originHost+capture);</span><br><span class="line">    	return tmp</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return match</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/18/2017-12-18-js正则替换图片路径/" data-id="cjbdfjnmx00047or315alkz03" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016-02-24-【转】git批量删除文件夹和文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/24/2016-02-24-【转】git批量删除文件夹和文件/" class="article-date">
  <time datetime="2016-02-24T04:06:10.000Z" itemprop="datePublished">2016-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/24/2016-02-24-【转】git批量删除文件夹和文件/">【转】git批量删除文件夹和文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>硬盘删除文件后，执行$ git status</p>
<p>会提示你仍然需要$ git rm &lt;文件&gt;</p>
<p>此时如果是要删除大批量文件，这么一个一个命令下去不得累死人啊</p>
<p>其实可以这样（不管之前有没有已经本地物理删除）</p>
<p>执行 $ git rm <em> -r（记得，cd 到你要删除的目录下。当然 </em> 可以换成指定目录）</p>
<p>这时删除文件已经进入本地缓存区，</p>
<p>接下来就是正常的提交操作了<br>$ git add .<br>$ git commit -m “clear”<br>$ git push origin master</p>
<p>from: <a href="http://blog.sina.com.cn/s/blog_658adf270102uy0m.html" target="_blank" rel="noopener">git 批量删除文件夹和文件</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/24/2016-02-24-【转】git批量删除文件夹和文件/" data-id="cjbdfjnmn00017or3dox2d311" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-02-18-meteor验证微信公众平台" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/18/2016-02-18-meteor验证微信公众平台/" class="article-date">
  <time datetime="2016-02-18T02:30:51.000Z" itemprop="datePublished">2016-02-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/18/2016-02-18-meteor验证微信公众平台/">meteor验证微信公众平台</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>进行微信开发的第一步是要接入，验证服务器地址的有效性。 官网只给了php的demo。网上也有很多介绍各种平台的验证方法。但是meteor验证token的方法网上还找不到。因为meteor与nodejs 有很深的渊源，我们可以借鉴 nodejs 验证微信开发平台的token 的方法来用meteor做一个验证。</p>
<h2 id="实施步骤"><a href="#实施步骤" class="headerlink" title="实施步骤"></a>实施步骤</h2><h3 id="meteor新建项目"><a href="#meteor新建项目" class="headerlink" title="meteor新建项目"></a>meteor新建项目</h3><p>以jhwx为例</p>
<p><img src="http://7xr0mq.com1.z0.glb.clouddn.com/20160218_step1.png" alt="新建项目"></p>
<h3 id="整理文件夹，编写代码"><a href="#整理文件夹，编写代码" class="headerlink" title="整理文件夹，编写代码"></a>整理文件夹，编写代码</h3><h4 id="删除meteor生成-的，html、css、js-文件。建立文件夹如图"><a href="#删除meteor生成-的，html、css、js-文件。建立文件夹如图" class="headerlink" title="删除meteor生成 的，html、css、js 文件。建立文件夹如图"></a>删除meteor生成 的，html、css、js 文件。建立文件夹如图</h4><p><img src="http://7xr0mq.com1.z0.glb.clouddn.com/20160218_step2.png" alt="整理文件夹"></p>
<p>为什么这样？参考了官方推荐的第二种文件组织方法。<a href="http://docs.meteor.com/#/full/structuringyourapp" target="_blank" rel="noopener">相关参考:Organizing Your Project</a></p>
<h4 id="把加密sha算法文件在server文件夹里"><a href="#把加密sha算法文件在server文件夹里" class="headerlink" title="把加密sha算法文件在server文件夹里"></a>把加密sha算法文件在server文件夹里</h4><p>在微信jssdk说明文档里下载官方的<a href="http://demo.open.weixin.qq.com/jssdk/sample.zip" target="_blank" rel="noopener">示例代码</a> ，解压里面的文件,在node\node_modules\jssha\src 文件家里，找到sha.js 。将其放到项目的server文件夹下。</p>
<h4 id="在server文件夹内新建main-js，代码如下"><a href="#在server文件夹内新建main-js，代码如下" class="headerlink" title="在server文件夹内新建main.js，代码如下"></a>在server文件夹内新建main.js，代码如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// Listen to incoming HTTP requests, can only be used on the server</span><br><span class="line">WebApp.connectHandlers.use(&quot;/validateToken&quot;, function(req, res, next) &#123;</span><br><span class="line"></span><br><span class="line">  var query = req.query;</span><br><span class="line">  //console.log(&quot;*** URL:&quot; + req.url);</span><br><span class="line">  //console.log(query);</span><br><span class="line">  var signature = query.signature;</span><br><span class="line">  var echostr = query.echostr;</span><br><span class="line">  var timestamp = query[&apos;timestamp&apos;];</span><br><span class="line">  var nonce = query.nonce;</span><br><span class="line">  var oriArray = new Array();</span><br><span class="line">  oriArray[0] = nonce;</span><br><span class="line">  oriArray[1] = timestamp;</span><br><span class="line">  oriArray[2] = &quot;cbb201512281359tiyanhao&quot;;//这里是你在微信开发者中心页面里填的token</span><br><span class="line">  oriArray.sort();</span><br><span class="line">  var original = oriArray.join(&apos;&apos;);</span><br><span class="line">  console.log(&quot;Original str : &quot; + original);</span><br><span class="line">  console.log(&quot;Signature : &quot; + signature );</span><br><span class="line">  //var scyptoString = sha1(original);</span><br><span class="line"></span><br><span class="line">  var shaObj2 = new jsSHA(original, &apos;TEXT&apos;);</span><br><span class="line">  scyptoString = shaObj2.getHash(&apos;SHA-1&apos;, &apos;HEX&apos;);</span><br><span class="line">  if(signature == scyptoString)&#123;</span><br><span class="line">    res.end(echostr);</span><br><span class="line">    console.log(&quot;Confirm and send echo back&quot;);</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    res.end(&quot;false&quot;);</span><br><span class="line">    console.log(&quot;Failed!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="部署发布"><a href="#部署发布" class="headerlink" title="部署发布"></a>部署发布</h3><p>运行命令</p>
<blockquote>
<p>meteor deploy jhwx.meteor.com</p>
</blockquote>
<p>ps: 有时候会很慢，不容易成功。翻墙是最好的选择。</p>
<h3 id="在公众号后台设置接口配置信息"><a href="#在公众号后台设置接口配置信息" class="headerlink" title="在公众号后台设置接口配置信息"></a>在公众号后台设置接口配置信息</h3><p>已测试号为例<br><img src="http://7xr0mq.com1.z0.glb.clouddn.com/20160218_step4.png" alt="设置接口配置信息"></p>
<p><font color="red">token的值与上面代码oriArray[2]的值要一样 </font><br>点击提交，多试几下，有可能是网络太慢导致无法配置成功。</p>
<h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><ol>
<li>隐约雷鸣 的<a href="https://segmentfault.com/a/1190000003012131" target="_blank" rel="noopener">NodeJS验证微信开发平台的token</a></li>
<li>NoGrief 的<a href="http://blog.csdn.net/nogrief/article/details/9774773" target="_blank" rel="noopener">（一）验证微信公众平台</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/18/2016-02-18-meteor验证微信公众平台/" data-id="cjbdfjno5000s7or3lcd1qxpj" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/meteor/">meteor</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微信公众平台/">微信公众平台</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-02-17-译-服务端路由选择-Server-Side-Routing-with-Picker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/17/2016-02-17-译-服务端路由选择-Server-Side-Routing-with-Picker/" class="article-date">
  <time datetime="2016-02-17T08:32:04.000Z" itemprop="datePublished">2016-02-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/17/2016-02-17-译-服务端路由选择-Server-Side-Routing-with-Picker/">[译]服务端路由选择---Server Side Routing with Picker</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>这节的内容</strong><br>在这节，我们将学习如何使用选择器来定义服务端的路由。如何定义一个路由和添加一些中间件来帮助我们解析请求。我们还将学习到如何使用选择器响应请求。<br><strong>目录</strong></p>
<ol>
<li>什么是服务端的路由</li>
<li>什么是选择器</li>
<li>定义带选择器的路由</li>
<li>添加中间件bodyParser</li>
<li>处理选择器的请求</li>
<li>过滤路由</li>
<li>小贴士</li>
</ol>
<h3 id="什么是服务端的路由"><a href="#什么是服务端的路由" class="headerlink" title="什么是服务端的路由"></a>什么是服务端的路由</h3><p>当我们为我们的应用定义路由是，有两种选择：客户端和服务端。客户端的路由是我们最熟悉的。客户通过客户端的路由可以访问特定的页面或呈现特定的内容（meteor中是一个模板）。每当有人通过浏览器的URL连接你的服务器，服务器就会查找相应的路由，然后执行路由提供的指令。<br>另一方面，服务端的路由不是用于客户端直接访问的。而是做一下内容其中的一个：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">接收传递的参数内容并返回它</td>
</tr>
<tr>
<td style="text-align:left">POST</td>
<td style="text-align:left">接收一些数据</td>
</tr>
<tr>
<td style="text-align:left">PUT</td>
<td style="text-align:left">接收的一些数据，然后或者更新传递的参数匹配现有的资源，或者，如果它不存在，创建使用传递的参数资源。</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">删除对应传递的参数的资源</td>
</tr>
</tbody>
</table>
<p>我们注意到Type这一列，有4个动词 GET,POST,PUT,DELETE，这和HTTP的方法相对应。我们也称请求方法。他们是<a href="http://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">HTTP/1.1协议</a>中<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods" target="_blank" rel="noopener">9种http请求方法中的4种</a>.该规范（a.k.a超文本传输协议）是一种用于开发在世界各地通过网络进行通信的“使用说明书”。在这节中，我们只关注最常用的这4种方法。</p>
<hr>
<p><strong>理解HTTP</strong><br>不要惊慌，你不需要去理解在服务端路由中使用的错综复杂的HTTP使用规范。但是，学习数据在互联网上传播的方式，将有助于理解它是如何影响您的应用程序。<a href="http://www.garshol.priv.no/download/text/http-tut.html" target="_blank" rel="noopener">点击这里学习更多</a></p>
<hr>
<p>服务器路由并不是为了在客户端直接互动，渲染或展示（除了显示在屏幕上的文字原始数据）。服务端路由的目的是允许你的应用程序响应其他应用程序的请求。</p>
<h3 id="选择器是什么"><a href="#选择器是什么" class="headerlink" title="选择器是什么"></a>选择器是什么</h3><p>选择器是Arunoda Susiripala和团队MeteorHacks写了一个独立的服务器端的路由包。</p>
<h3 id="定义带选择器的路由"><a href="#定义带选择器的路由" class="headerlink" title="定义带选择器的路由"></a>定义带选择器的路由</h3><h3 id="添加中间件bodyParser"><a href="#添加中间件bodyParser" class="headerlink" title="添加中间件bodyParser"></a>添加中间件bodyParser</h3><h3 id="处理选择器的请求"><a href="#处理选择器的请求" class="headerlink" title="处理选择器的请求"></a>处理选择器的请求</h3><h3 id="过滤路由"><a href="#过滤路由" class="headerlink" title="过滤路由"></a>过滤路由</h3><h3 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h3><p>(未完待续)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/17/2016-02-17-译-服务端路由选择-Server-Side-Routing-with-Picker/" data-id="cjbdfjnmh00007or3mrh5776o" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/meteor/">meteor</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-折腾HEXO的二三事" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/16/折腾HEXO的二三事/" class="article-date">
  <time datetime="2016-02-16T10:32:55.000Z" itemprop="datePublished">2016-02-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/闲言碎语/">闲言碎语</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/16/折腾HEXO的二三事/">折腾HEXO的二三事</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>折腾了一天，终于把hexo弄到github了。去年已经做了一个版本，找了几个皮肤都不太满意，加上好久没弄，又忘的差不多了 。今天重新做了一个，换了next皮肤，感觉不错。</p>
<h2 id="为何用hexo"><a href="#为何用hexo" class="headerlink" title="为何用hexo"></a>为何用hexo</h2><p>去年浏览网站的时候无意中发现了这个东西。<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a> ，通过了解和尝试，发现这个东东还真的蛮简单的，非常适合有点儿技术知识的bloger。<br>英文ok的，可以通过官网的文档可以快速的开始hexo之旅。</p>
<p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a>,主题做了很好的说明是很受欢迎的主题皮肤。根据NexT官网的步骤也很快的进行设置。</p>
<h2 id="如何用hexo-写文章"><a href="#如何用hexo-写文章" class="headerlink" title="如何用hexo 写文章"></a>如何用hexo 写文章</h2><h3 id="1-创建标题，在博客目录使用命令"><a href="#1-创建标题，在博客目录使用命令" class="headerlink" title="1. 创建标题，在博客目录使用命令"></a>1. 创建标题，在博客目录使用命令</h3><blockquote>
<p>hexo new [layout] <title></title></p>
</blockquote>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;折腾HEXO的二三事&quot;</span><br></pre></td></tr></table></figure></p>
<p>layout 有post、page、draft 可选 ，更多用法见：<a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">https://hexo.io/docs/writing.html</a><br>运行以上命令后会在 source / _posts 目录下生成“折腾HEXO的二三事.md”这个文件，sublime打开这个文件就可以开始写文章了。</p>
<h3 id="2-写文章"><a href="#2-写文章" class="headerlink" title="2. 写文章"></a>2. 写文章</h3><p>打开文件后可以看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 折腾HEXO的二三事</span><br><span class="line">date: 2016-02-16 18:32:55</span><br><span class="line">tags:</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>title 很容易理解就是文章的标题<br>date 就是这篇文章的创建时间<br>tags 标签</p>
<p>在- - -前还可以做好多事情</p>
<ol>
<li>可以添加多个tag<blockquote>
<p>tags:<br>- hexo<br>- blog</p>
</blockquote>
</li>
<li>添加分类，类似tags<blockquote>
<p>categories:<br>- 闲言碎语</p>
</blockquote>
</li>
<li>添加简述，添加后在首页不会显示文章全文，只显示简述，如何会有阅读更多的按钮<blockquote>
<p>description: “这里是简述的内容，最好用双引号包起来，在首页那双引号不会显示出来”</p>
</blockquote>
</li>
</ol>
<h2 id="hexo建站相关文章"><a href="#hexo建站相关文章" class="headerlink" title="hexo建站相关文章"></a>hexo建站相关文章</h2><ol>
<li><a href="http://jingyan.baidu.com/article/d8072ac47aca0fec95cefd2d.html" target="_blank" rel="noopener">史上最详细“截图”搭建Hexo博客并部署到Github</a></li>
<li><a href="http://www.arao.me/2015/hexo-next-theme-optimize-base/" target="_blank" rel="noopener">动动手指，NexT主题与Hexo更搭哦（基础篇）</a></li>
<li><a href="http://www.zipperary.com/2013/05/29/hexo-guide-3/" target="_blank" rel="noopener">hexo系列教程：（三）hexo博客的配置、使用</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/16/折腾HEXO的二三事/" data-id="cjbdfjnn700097or3b7y2wlc9" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-angularjs-学习的那些事儿(2)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/16/angularjs-学习的那些事儿(2)/" class="article-date">
  <time datetime="2016-02-16T04:02:49.000Z" itemprop="datePublished">2016-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/16/angularjs-学习的那些事儿(2)/">angularjs-学习的那些事儿(2)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>控制器的设计出发点是封装单个视图的业务逻辑，因此，不要进行以下操作：</p>
<ul>
<li><p>DOM操作<br>应当将DOM操作使用指令/directive进行封装。</p>
</li>
<li><p>变换输出形式<br>应当使用过滤器/filter对输出显示进行转化。</p>
</li>
<li><p>跨控制器共享代码<br>对于需要复用的基础代码，应当使用服务/service进行封装</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/16/angularjs-学习的那些事儿(2)/" data-id="cjbdfjno2000q7or3jzkfc7qr" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-转-AngularJS-应用身份认证的技巧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/15/转-AngularJS-应用身份认证的技巧/" class="article-date">
  <time datetime="2016-02-15T09:50:42.000Z" itemprop="datePublished">2016-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/15/转-AngularJS-应用身份认证的技巧/">[转]AngularJS 应用身份认证的技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>最普遍的身份认证方式就是用用户名（或 email）和密码做登陆操作。这就意味要实现一个登陆的表单，以便用户能够用他们个人信息登陆。这个表单看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form name=&quot;loginForm&quot; ng-controller=&quot;LoginController&quot; ng-submit=&quot;login(credentials)&quot; novalidate=&quot;&quot;&gt;</span><br><span class="line">  &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; id=&quot;username&quot; ng-model=&quot;credentials.username&quot; /&gt;</span><br><span class="line">  &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;password&quot; id=&quot;password&quot; ng-model=&quot;credentials.password&quot; /&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure></p>
<p>既然这个是 Angular-powered 的表单，我们使用 ngSubmit 指令去触发上传表单时的函数。注意一点的是，我们把个人信息传入到上传表单的函数，而不是直接使用 $scope.credentials 这个对象。这样使得函数更容易进行 unit-test 和降低这个函数与当前 Controller 作用域的耦合。这个 Controller 看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.controller(&apos;LoginController&apos;,</span><br><span class="line">function($scope, $rootScope, AUTH_EVENTS, AuthService) &#123;</span><br><span class="line">    $scope.credentials = &#123;</span><br><span class="line">        username: &apos;&apos;,</span><br><span class="line">        password: &apos;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    $scope.login = function(credentials) &#123;</span><br><span class="line">        AuthService.login(credentials).then(function(user) &#123;</span><br><span class="line">            $rootScope.$broadcast(AUTH_EVENTS.loginSuccess);</span><br><span class="line">            $scope.setCurrentUser(user);</span><br><span class="line">        &#125;,</span><br><span class="line">        function() &#123;</span><br><span class="line">            $rootScope.$broadcast(AUTH_EVENTS.loginFailed);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    javascript: void(0);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们注意到这里是缺少实际的逻辑的。这个 Controller 被做成这样，目的是使身份认证的逻辑跟表单解耦。把逻辑尽可能的从我们的 Controller 里面抽离出来，把他们都放到 services 里面，这是个很好的想法。AngularJS 的 Controller 应该只管理 $scope 里面的对象（用 watching 或者 手动操作）而不是承担过多过分重的东西。<br>通知 Session 的变化</p>
<p>身份认证会影响整个应用的状态。基于这个原因我更推荐使用事件（用 $broadcast）去通知 user session 的改变。把所有可能用到的事件代码定义在一个中间地带是个不错的选择。我喜欢用 constants 去做这个事情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.constant(&apos;AUTH_EVENTS&apos;, &#123;</span><br><span class="line">    loginSuccess: &apos;auth-login-success&apos;,</span><br><span class="line">    loginFailed: &apos;auth-login-failed&apos;,</span><br><span class="line">    logoutSuccess: &apos;auth-logout-success&apos;,</span><br><span class="line">    sessionTimeout: &apos;auth-session-timeout&apos;,</span><br><span class="line">    notAuthenticated: &apos;auth-not-authenticated&apos;,</span><br><span class="line">    notAuthorized: &apos;auth-not-authorized&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>constants 有个很好的特性就是他们能随便注入到别的地方，就像 services 那样。这样使得 constants 很容易被我们的 unit-test 调用。constants 也允许你很容易地在随后对他们重命名而不需要改一大串文件。同样的戏法运用到了 user roles:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.constant(&apos;USER_ROLES&apos;, &#123;</span><br><span class="line">    all: &apos;*&apos;,</span><br><span class="line">    admin: &apos;admin&apos;,</span><br><span class="line">    editor: &apos;editor&apos;,</span><br><span class="line">    guest: &apos;guest&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>如果你想给予 editors 和 administrators 同样的权限，你只需要简单地把 ‘editor’ 改成 ‘admin’。<br>The AuthService</p>
<p>与身份认证和授权（访问控制）相关的逻辑最好被放到同一个 service：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.factory(&apos;AuthService&apos;,</span><br><span class="line">function($http, Session) &#123;</span><br><span class="line">    var authService = &#123;&#125;;</span><br><span class="line">    authService.login = function(credentials) &#123;</span><br><span class="line">        return $http.post(&apos;/login&apos;, credentials).then(function(res) &#123;</span><br><span class="line">            Session.create(res.data.id, res.data.user.id, res.data.user.role);</span><br><span class="line">            return res.data.user;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    authService.isAuthenticated = function() &#123;</span><br><span class="line">        return !! Session.userId;</span><br><span class="line">    &#125;;</span><br><span class="line">    authService.isAuthorized = function(authorizedRoles) &#123;</span><br><span class="line">        if (!angular.isArray(authorizedRoles)) &#123;</span><br><span class="line">            authorizedRoles = [authorizedRoles];</span><br><span class="line">        &#125;</span><br><span class="line">        return (authService.isAuthenticated() &amp;&amp; authorizedRoles.indexOf(Session.userRole) !== -1);</span><br><span class="line">    &#125;;</span><br><span class="line">    return authService;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>为了进一步远离身份认证的担忧，我使用另一个 service（一个单例对象，using the service style）去保存用户的 session 信息。session 的信息细节是依赖于后端的实现，但是我还是给出一个较普遍的例子吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.service(&apos;Session&apos;,</span><br><span class="line">function() &#123;</span><br><span class="line">    this.create = function(sessionId, userId, userRole) &#123;</span><br><span class="line">        this.id = sessionId;</span><br><span class="line">        this.userId = userId;</span><br><span class="line">        this.userRole = userRole;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.destroy = function() &#123;</span><br><span class="line">        this.id = null;</span><br><span class="line">        this.userId = null;</span><br><span class="line">        this.userRole = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>一旦用户登录了，他的信息应该会被展示在某些地方（比如右上角用户头像什么的）。为了实现这个，用户对象必须要被 $scope 对象引用，更好的是一个可以被全局调用的地方。虽然 $rootScope 是显然易见的第一个选择，但是我尝试克制自己，不过多地使用 $rootScope（实际上我只在全局事件广播使用 $rootScope）。用我所喜欢的方式去做这个事情，就是在应用的根节点，或者在别的至少高于 Dom 树的地方，定义一个 controller 。 标签是个很好的选择：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body ng-controller=&quot;ApplicationController&quot;&gt; ... &lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p>ApplicationController 是应用的全局逻辑的容器和一个用于运行 Angular 的 run 方法的选择。因此它要处于 $scope 树的根，所有其他的 scope 会继承它（除了隔离 scope）。这是个很好的地方去定义 currentUser 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.controller(&apos;ApplicationController&apos;,</span><br><span class="line">function($scope, USER_ROLES, AuthService) &#123;</span><br><span class="line">    $scope.currentUser = null;</span><br><span class="line">    $scope.userRoles = USER_ROLES;</span><br><span class="line">    $scope.isAuthorized = AuthService.isAuthorized;</span><br><span class="line">    $scope.setCurrentUser = function(user) &#123;</span><br><span class="line">        $scope.currentUser = user;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们实际上不分配 currentUser 对象，我们仅仅初始化作用域上的属性以便 currentUser 能在后面被访问到。不幸的是，我们不能简单地在子作用域分配一个新的值给 currentUser 因为那样会造成 shadow property。这是用以值传递原始类型（strings， numbers， booleans，undefined and null）代替以引用传递原始类型的结果。为了防止 shadow property，我们要使用 setter 函数。如果想了解更多 Angular 作用域和原形继承，请阅读 Understanding Scopes。</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>身份认证，也就是访问控制，其实在 AngularJS 并不存在。因为我们是客户端应用，所有源码都在用户手上。没有办法阻止用户篡改代码以获得认证后的界面。我们能做的只是显示控制。如果你需要真正的身份认证，你需要在服务器端做这个事情，但是这个超出了本文范畴。</p>
<h2 id="限制元素的显示"><a href="#限制元素的显示" class="headerlink" title="限制元素的显示"></a>限制元素的显示</h2><p>AngularJS 拥有基于作用域或者表达式来控制显示或者隐藏元素的指令： ngShow， ngHide， ngIf 和 ngSwitch。前两个会使用一个 style 属性去隐藏元素，但是后两个会从 DOM 移除元素。</p>
<p>第一种方式，也就是隐藏元素，最好用于表达式频繁改变并且没有包含过多的模板逻辑和作用域引用的元素上。原因是在隐藏的元素里，这些元素的模板逻辑仍然会在每个 digest 循环里重新计算，使得应用性能下降。第二种方式，移除元素，也会移除所有在这个元素上的 handler 和作用域绑定。改变 DOM 对于浏览器来说是很大工作量的（在某些场景，和 ngShow/ngHide 对比），但是在很多时候这种代价是值得的。因为用户访问信息不会经常改变，使用 ngIf 或 ngShow 是最好的选择：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-if=&quot;currentUser&quot;&gt;</span><br><span class="line">  Welcome, &#123;&#123; currentUser.name &#125;&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> &lt;div ng-if=&quot;isAuthorized(userRoles.admin)&quot;&gt;</span><br><span class="line">  You&apos;re admin.</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> &lt;div ng-switch=&quot;&quot; on=&quot;currentUser.role&quot;&gt;</span><br><span class="line">  &lt;div ng-switch-when=&quot;userRoles.admin&quot;&gt;</span><br><span class="line">   You&apos;re admin.</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div ng-switch-when=&quot;userRoles.editor&quot;&gt;</span><br><span class="line">   You&apos;re editor.</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div ng-switch-default=&quot;&quot;&gt;</span><br><span class="line">   You&apos;re something else.</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="限制路由访问"><a href="#限制路由访问" class="headerlink" title="限制路由访问"></a>限制路由访问</h2><p>很多时候你会想让整个网页都不能被访问，而不是仅仅隐藏一个元素。如果可以再路由（在UI Router 里，路由也叫状态）使用一种自定义的数据结构，我们就可以明确哪些用户角色可以被允许访问哪些内容。下面这个例子使用 UI Router 的风格，但是这些同样适用于 ngRoute。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.config(function($stateProvider, USER_ROLES) &#123;</span><br><span class="line">    $stateProvider.state(&apos;dashboard&apos;, &#123;</span><br><span class="line">        url: &apos;/dashboard&apos;,</span><br><span class="line">        templateUrl: &apos;dashboard/index.html&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            authorizedRoles: [USER_ROLES.admin, USER_ROLES.editor]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>下一步，我们需要检查每次路由变化（就是用户跳转到其他页面的时候）。这需要监听 $routeChangStart（ngRoute 里的）或者 $stateChangeStart（UI Router 里的）事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.run(function($rootScope, AUTH_EVENTS, AuthService) &#123;</span><br><span class="line">    $rootScope.$on(&apos;$stateChangeStart&apos;,</span><br><span class="line">    function(event, next) &#123;</span><br><span class="line">        var authorizedRoles = next.data.authorizedRoles;</span><br><span class="line">        if (!AuthService.isAuthorized(authorizedRoles)) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">            if (AuthService.isAuthenticated()) &#123; </span><br><span class="line">                // user is not allowed        </span><br><span class="line">                $rootScope.$broadcast(AUTH_EVENTS.notAuthorized);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // user is not logged in        </span><br><span class="line">                $rootScope.$broadcast(AUTH_EVENTS.notAuthenticated);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="Session-时效"><a href="#Session-时效" class="headerlink" title="Session 时效"></a>Session 时效</h2><p>身份认证多半是服务器端的事情。无论你用什么实现方式，你的后端会对用户信息做真正的验证和处理诸如 Session 时效和访问控制的处理。这意味着你的 API 会有时返回一些认证错误。标准的错误码就是 HTTP 状态吗。普遍使用这些错误码：</p>
<p>401 Unauthorized — The user is not logged in<br>403 Forbidden — The user is logged in but isn’t allowed access<br>419 Authentication Timeout (non standard) — Session has expired<br>440 Login Timeout (Microsoft only) — Session has expired<br>后两种不是标准内容，但是可能广泛应用。最好的官方的判断 session 过期的错误码是 401。无论怎样，你的登陆对话框都应该在 API 返回 401， 419， 440 或者 403 的时候马上显示出来。总的来说，我们想广播和基于这些 HTTP 返回码的时间，为此我们在 $httpProvider 增加一个拦截器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.config(function($httpProvider) &#123;</span><br><span class="line">    $httpProvider.interceptors.push([&apos;$injector&apos;,</span><br><span class="line">    function($injector) &#123;</span><br><span class="line">        return $injector.get(&apos;AuthInterceptor&apos;);</span><br><span class="line">    &#125;]);</span><br><span class="line">&#125;)</span><br><span class="line">.factory(&apos;AuthInterceptor&apos;,</span><br><span class="line">function($rootScope, $q, AUTH_EVENTS) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        responseError: function(response) &#123;</span><br><span class="line">            $rootScope.$broadcast(&#123;</span><br><span class="line">                401 : AUTH_EVENTS.notAuthenticated,</span><br><span class="line">                403 : AUTH_EVENTS.notAuthorized,</span><br><span class="line">                419 : AUTH_EVENTS.sessionTimeout,</span><br><span class="line">                440 : AUTH_EVENTS.sessionTimeout</span><br><span class="line">            &#125; [response.status], response);</span><br><span class="line">            return $q.reject(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这只是一个认证拦截器的简单实现。有个很棒的项目在 Github ，它做了相同的事情，并且使用了 httpBuffer 服务。当返回 HTTP 错误码时，它会阻止用户进一步的请求，直到用户再次登录，然后继续这个请求。</p>
<h2 id="登录对话框指令"><a href="#登录对话框指令" class="headerlink" title="登录对话框指令"></a>登录对话框指令</h2><p>当一个 session 过期了，我们需要用户重新进入他的账号。为了防止他丢失他当前的工作，最好的方法就是弹出登录登录对话框，而不是跳转到登录页面。这个对话框需要监听 notAuthenticated 和 sessionTimeout 事件，所以当其中一个事件被触发了，对话框就要打开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.directive(&apos;loginDialog&apos;,</span><br><span class="line">function(AUTH_EVENTS) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        restrict: &apos;A&apos;,</span><br><span class="line">        template: &apos;&lt;div ng-if=&quot;visible&quot;  ng-include=&quot;\&apos;login-form.html\&apos;&quot;&gt;&apos;,</span><br><span class="line">        link: function(scope) &#123;</span><br><span class="line">            var showDialog = function() &#123;</span><br><span class="line">                scope.visible = true;</span><br><span class="line">            &#125;;</span><br><span class="line">            scope.visible = false;</span><br><span class="line">            scope.$on(AUTH_EVENTS.notAuthenticated, showDialog);</span><br><span class="line">            scope.$on(AUTH_EVENTS.sessionTimeout, showDialog)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>只要你喜欢，这个对话框可以随便扩展。主要的思想是重用已存在的登陆表单模板和 LoginController。你需要在每个页面写上如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div login-dialog ng-if=&quot;!isLoginPage&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意 isLoginPage 检查。一个失败了的登陆会触发 notAuthenticated 时间，但我们不想在登陆页面显示这个对话框，因为这很多余和奇怪。这就是为什么我们不把登陆对话框也放在登陆页面的原因。所以在 ApplicationController 里定义一个 $scope.isLoginPage 是合理的。</p>
<h2 id="保存用户状态"><a href="#保存用户状态" class="headerlink" title="保存用户状态"></a>保存用户状态</h2><p>在用户刷新他们的页面，依旧保存已登陆的用户信息是单页应用认证里面狡猾的一个环节。因为所有状态都存在客户端，刷新会清空用户信息。为了修复这个问题，我通常实现一个会返回已登陆的当前用户的数据的 API （比如 /profile），这个 API 会在 AngularJS 应用启动（比如在 “run” 函数）。然后用户数据会被保存在 Session 服务或者 $rootScope，就像用户已经登陆后的状态。或者，你可以把用户数据直接嵌入到 index.html，这样就不用额外的请求了。第三种方式就是把用户数据存在 cookie 或者 LocalStorage，但这会使得登出或者清空用户数据变得困难一点。</p>
<p>最后……</p>
<p>鄙人才疏学浅，一点点经验，这是一篇翻译的文章，如有谬误，欢迎指正。</p>
<p>原文章作者：<a href="https://coding.net/u/huangruichang" target="_blank" rel="noopener">huangruichang</a></p>
<p>参考阅读</p>
<p><a href="https://medium.com/opinionated-angularjs/techniques-for-authentication-in-angularjs-applications-7bbf0346acec" target="_blank" rel="noopener">Techniques for authentication in AngularJS applications</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/15/转-AngularJS-应用身份认证的技巧/" data-id="cjbdfjnn200067or30gdgdita" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/angularjs/">angularjs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-angularjs-学习的那些事儿(1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/15/angularjs-学习的那些事儿(1)/" class="article-date">
  <time datetime="2016-02-15T09:40:12.000Z" itemprop="datePublished">2016-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/15/angularjs-学习的那些事儿(1)/">angularjs 学习的那些事儿(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、为什么学习angularjs"><a href="#一、为什么学习angularjs" class="headerlink" title="一、为什么学习angularjs"></a>一、为什么学习angularjs</h3><p>在现有的前端工程师的招聘中很多都需要掌握这样的框架。说明这是一个比较热门的框架。如果需要继续在前端发展，了解他是不可或缺的。</p>
<h3 id="二、如何学习angularjs"><a href="#二、如何学习angularjs" class="headerlink" title="二、如何学习angularjs"></a>二、如何学习angularjs</h3><h4 id="1-了解angularjs的核心"><a href="#1-了解angularjs的核心" class="headerlink" title="1.了解angularjs的核心"></a>1.了解angularjs的核心</h4><p>AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。</p>
<h4 id="2-了解angularjs的理念"><a href="#2-了解angularjs的理念" class="headerlink" title="2.了解angularjs的理念"></a>2.了解angularjs的理念</h4><p>Angular信奉的是，当组建视图(UI)同时又要写软件逻辑时，<font color="red">声明式的代码</font>会比命令式的代码好得多，尽管命令式的代码非常适合用来表述业务逻辑。</p>
<h4 id="3-了解别人对angularjs的评价"><a href="#3-了解别人对angularjs的评价" class="headerlink" title="3.了解别人对angularjs的评价"></a>3.了解别人对angularjs的评价</h4><p><a href="http://www.zhihu.com/question/22284218" target="_blank" rel="noopener">AngularJS 在实际应用中有哪些优缺点？</a><br><a href="http://damoqiongqiu.iteye.com/blog/2255046" target="_blank" rel="noopener">代码狗必看：前端开发3大坑</a></p>
<h4 id="4-了解angularjs的适用场景"><a href="#4-了解angularjs的适用场景" class="headerlink" title="4.了解angularjs的适用场景"></a>4.了解angularjs的适用场景</h4><ul>
<li>AngularJS主要考虑的是构建CRUD（增加Create、查询Retrieve、更新Update、删除Delete）应用。</li>
<li>AngularJS的目标之一是简化开发过程，这使得AngularJS非常善于构建小型app原型。</li>
<li>如游戏，图形界面编辑器，这种DOM操作很频繁也很复杂的应用不适合用AngularJS来构建。像这种情况用一些更轻量、简单的技术如jQuery可能会更好。</li>
</ul>
<h3 id="三、Angular中service、controller、directive的认识和理解如下"><a href="#三、Angular中service、controller、directive的认识和理解如下" class="headerlink" title="三、Angular中service、controller、directive的认识和理解如下"></a>三、Angular中service、controller、directive的认识和理解如下</h3><p>Service就是单例对象在AngluarJS 中的一个别名。这些单例对象会被经常传来传去，保证你每次访问到的都是同一个实例。基于这种思想，单例对象让我们可以实现一些相当酷的功能，它可以让很多controller和directive访问其内部的数值。</p>
<p>controller把service、依赖关系、以及其它对象串联到一起，然后通过scope把它们关联到view上。如果在你的视图里面需要处理复杂的业务逻辑，那么把它们放到controller里面也是一个非常不错的选择。</p>
<p><strong>Controller 使用过程中的注意点</strong></p>
<ul>
<li>不要试图复用Controller , 一个控制器一般只负责一小块视图</li>
<li>不要在Controller中操作DOM，这不是控制器的职责</li>
<li>不要在Controller里做数据格式化，ng有很好用的表单控件</li>
<li>不要在Controller里做数据过滤操作，ng有$filter服务</li>
<li>一般来说，<font color="red">Controller是不会互相调用的</font>，控制器之间的交互会通过事件进行</li>
</ul>
<p>Angular对directive的定义是一段代码片段，你可以用它来操作DOM，也可以使用它来进行用户交互。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/15/angularjs-学习的那些事儿(1)/" data-id="cjbdfjnn000057or3c47be07v" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/angularjs/">angularjs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术/">前端技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/闲言碎语/">闲言碎语</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/angularjs/">angularjs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/meteor/">meteor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信公众平台/">微信公众平台</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/angularjs/" style="font-size: 20px;">angularjs</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/meteor/" style="font-size: 20px;">meteor</a> <a href="/tags/前端/" style="font-size: 20px;">前端</a> <a href="/tags/微信公众平台/" style="font-size: 10px;">微信公众平台</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/18/2017-12-18-js正则替换图片路径/">js正则替换图片路径</a>
          </li>
        
          <li>
            <a href="/2016/02/24/2016-02-24-【转】git批量删除文件夹和文件/">【转】git批量删除文件夹和文件</a>
          </li>
        
          <li>
            <a href="/2016/02/18/2016-02-18-meteor验证微信公众平台/">meteor验证微信公众平台</a>
          </li>
        
          <li>
            <a href="/2016/02/17/2016-02-17-译-服务端路由选择-Server-Side-Routing-with-Picker/">[译]服务端路由选择---Server Side Routing with Picker</a>
          </li>
        
          <li>
            <a href="/2016/02/16/折腾HEXO的二三事/">折腾HEXO的二三事</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>