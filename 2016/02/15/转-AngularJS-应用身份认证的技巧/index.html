<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[转]AngularJS 应用身份认证的技巧 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在都很多网站我们都需要对应用身份进行认证，而认证方式又有很多种，那么在angularjs中如何操作呢，本文将逐一介绍。">
<meta name="keywords" content="angularjs,前端">
<meta property="og:type" content="article">
<meta property="og:title" content="[转]AngularJS 应用身份认证的技巧">
<meta property="og:url" content="http://yoursite.com/2016/02/15/转-AngularJS-应用身份认证的技巧/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="在都很多网站我们都需要对应用身份进行认证，而认证方式又有很多种，那么在angularjs中如何操作呢，本文将逐一介绍。">
<meta property="og:updated_time" content="2016-02-16T03:26:13.651Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[转]AngularJS 应用身份认证的技巧">
<meta name="twitter:description" content="在都很多网站我们都需要对应用身份进行认证，而认证方式又有很多种，那么在angularjs中如何操作呢，本文将逐一介绍。">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-转-AngularJS-应用身份认证的技巧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/15/转-AngularJS-应用身份认证的技巧/" class="article-date">
  <time datetime="2016-02-15T09:50:42.000Z" itemprop="datePublished">2016-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      [转]AngularJS 应用身份认证的技巧
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>最普遍的身份认证方式就是用用户名（或 email）和密码做登陆操作。这就意味要实现一个登陆的表单，以便用户能够用他们个人信息登陆。这个表单看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form name=&quot;loginForm&quot; ng-controller=&quot;LoginController&quot; ng-submit=&quot;login(credentials)&quot; novalidate=&quot;&quot;&gt;</span><br><span class="line">  &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; id=&quot;username&quot; ng-model=&quot;credentials.username&quot; /&gt;</span><br><span class="line">  &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;password&quot; id=&quot;password&quot; ng-model=&quot;credentials.password&quot; /&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure></p>
<p>既然这个是 Angular-powered 的表单，我们使用 ngSubmit 指令去触发上传表单时的函数。注意一点的是，我们把个人信息传入到上传表单的函数，而不是直接使用 $scope.credentials 这个对象。这样使得函数更容易进行 unit-test 和降低这个函数与当前 Controller 作用域的耦合。这个 Controller 看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.controller(&apos;LoginController&apos;,</span><br><span class="line">function($scope, $rootScope, AUTH_EVENTS, AuthService) &#123;</span><br><span class="line">    $scope.credentials = &#123;</span><br><span class="line">        username: &apos;&apos;,</span><br><span class="line">        password: &apos;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    $scope.login = function(credentials) &#123;</span><br><span class="line">        AuthService.login(credentials).then(function(user) &#123;</span><br><span class="line">            $rootScope.$broadcast(AUTH_EVENTS.loginSuccess);</span><br><span class="line">            $scope.setCurrentUser(user);</span><br><span class="line">        &#125;,</span><br><span class="line">        function() &#123;</span><br><span class="line">            $rootScope.$broadcast(AUTH_EVENTS.loginFailed);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    javascript: void(0);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们注意到这里是缺少实际的逻辑的。这个 Controller 被做成这样，目的是使身份认证的逻辑跟表单解耦。把逻辑尽可能的从我们的 Controller 里面抽离出来，把他们都放到 services 里面，这是个很好的想法。AngularJS 的 Controller 应该只管理 $scope 里面的对象（用 watching 或者 手动操作）而不是承担过多过分重的东西。<br>通知 Session 的变化</p>
<p>身份认证会影响整个应用的状态。基于这个原因我更推荐使用事件（用 $broadcast）去通知 user session 的改变。把所有可能用到的事件代码定义在一个中间地带是个不错的选择。我喜欢用 constants 去做这个事情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.constant(&apos;AUTH_EVENTS&apos;, &#123;</span><br><span class="line">    loginSuccess: &apos;auth-login-success&apos;,</span><br><span class="line">    loginFailed: &apos;auth-login-failed&apos;,</span><br><span class="line">    logoutSuccess: &apos;auth-logout-success&apos;,</span><br><span class="line">    sessionTimeout: &apos;auth-session-timeout&apos;,</span><br><span class="line">    notAuthenticated: &apos;auth-not-authenticated&apos;,</span><br><span class="line">    notAuthorized: &apos;auth-not-authorized&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>constants 有个很好的特性就是他们能随便注入到别的地方，就像 services 那样。这样使得 constants 很容易被我们的 unit-test 调用。constants 也允许你很容易地在随后对他们重命名而不需要改一大串文件。同样的戏法运用到了 user roles:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.constant(&apos;USER_ROLES&apos;, &#123;</span><br><span class="line">    all: &apos;*&apos;,</span><br><span class="line">    admin: &apos;admin&apos;,</span><br><span class="line">    editor: &apos;editor&apos;,</span><br><span class="line">    guest: &apos;guest&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>如果你想给予 editors 和 administrators 同样的权限，你只需要简单地把 ‘editor’ 改成 ‘admin’。<br>The AuthService</p>
<p>与身份认证和授权（访问控制）相关的逻辑最好被放到同一个 service：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.factory(&apos;AuthService&apos;,</span><br><span class="line">function($http, Session) &#123;</span><br><span class="line">    var authService = &#123;&#125;;</span><br><span class="line">    authService.login = function(credentials) &#123;</span><br><span class="line">        return $http.post(&apos;/login&apos;, credentials).then(function(res) &#123;</span><br><span class="line">            Session.create(res.data.id, res.data.user.id, res.data.user.role);</span><br><span class="line">            return res.data.user;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    authService.isAuthenticated = function() &#123;</span><br><span class="line">        return !! Session.userId;</span><br><span class="line">    &#125;;</span><br><span class="line">    authService.isAuthorized = function(authorizedRoles) &#123;</span><br><span class="line">        if (!angular.isArray(authorizedRoles)) &#123;</span><br><span class="line">            authorizedRoles = [authorizedRoles];</span><br><span class="line">        &#125;</span><br><span class="line">        return (authService.isAuthenticated() &amp;&amp; authorizedRoles.indexOf(Session.userRole) !== -1);</span><br><span class="line">    &#125;;</span><br><span class="line">    return authService;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>为了进一步远离身份认证的担忧，我使用另一个 service（一个单例对象，using the service style）去保存用户的 session 信息。session 的信息细节是依赖于后端的实现，但是我还是给出一个较普遍的例子吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.service(&apos;Session&apos;,</span><br><span class="line">function() &#123;</span><br><span class="line">    this.create = function(sessionId, userId, userRole) &#123;</span><br><span class="line">        this.id = sessionId;</span><br><span class="line">        this.userId = userId;</span><br><span class="line">        this.userRole = userRole;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.destroy = function() &#123;</span><br><span class="line">        this.id = null;</span><br><span class="line">        this.userId = null;</span><br><span class="line">        this.userRole = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>一旦用户登录了，他的信息应该会被展示在某些地方（比如右上角用户头像什么的）。为了实现这个，用户对象必须要被 $scope 对象引用，更好的是一个可以被全局调用的地方。虽然 $rootScope 是显然易见的第一个选择，但是我尝试克制自己，不过多地使用 $rootScope（实际上我只在全局事件广播使用 $rootScope）。用我所喜欢的方式去做这个事情，就是在应用的根节点，或者在别的至少高于 Dom 树的地方，定义一个 controller 。 标签是个很好的选择：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body ng-controller=&quot;ApplicationController&quot;&gt; ... &lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p>ApplicationController 是应用的全局逻辑的容器和一个用于运行 Angular 的 run 方法的选择。因此它要处于 $scope 树的根，所有其他的 scope 会继承它（除了隔离 scope）。这是个很好的地方去定义 currentUser 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.controller(&apos;ApplicationController&apos;,</span><br><span class="line">function($scope, USER_ROLES, AuthService) &#123;</span><br><span class="line">    $scope.currentUser = null;</span><br><span class="line">    $scope.userRoles = USER_ROLES;</span><br><span class="line">    $scope.isAuthorized = AuthService.isAuthorized;</span><br><span class="line">    $scope.setCurrentUser = function(user) &#123;</span><br><span class="line">        $scope.currentUser = user;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们实际上不分配 currentUser 对象，我们仅仅初始化作用域上的属性以便 currentUser 能在后面被访问到。不幸的是，我们不能简单地在子作用域分配一个新的值给 currentUser 因为那样会造成 shadow property。这是用以值传递原始类型（strings， numbers， booleans，undefined and null）代替以引用传递原始类型的结果。为了防止 shadow property，我们要使用 setter 函数。如果想了解更多 Angular 作用域和原形继承，请阅读 Understanding Scopes。</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>身份认证，也就是访问控制，其实在 AngularJS 并不存在。因为我们是客户端应用，所有源码都在用户手上。没有办法阻止用户篡改代码以获得认证后的界面。我们能做的只是显示控制。如果你需要真正的身份认证，你需要在服务器端做这个事情，但是这个超出了本文范畴。</p>
<h2 id="限制元素的显示"><a href="#限制元素的显示" class="headerlink" title="限制元素的显示"></a>限制元素的显示</h2><p>AngularJS 拥有基于作用域或者表达式来控制显示或者隐藏元素的指令： ngShow， ngHide， ngIf 和 ngSwitch。前两个会使用一个 style 属性去隐藏元素，但是后两个会从 DOM 移除元素。</p>
<p>第一种方式，也就是隐藏元素，最好用于表达式频繁改变并且没有包含过多的模板逻辑和作用域引用的元素上。原因是在隐藏的元素里，这些元素的模板逻辑仍然会在每个 digest 循环里重新计算，使得应用性能下降。第二种方式，移除元素，也会移除所有在这个元素上的 handler 和作用域绑定。改变 DOM 对于浏览器来说是很大工作量的（在某些场景，和 ngShow/ngHide 对比），但是在很多时候这种代价是值得的。因为用户访问信息不会经常改变，使用 ngIf 或 ngShow 是最好的选择：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-if=&quot;currentUser&quot;&gt;</span><br><span class="line">  Welcome, &#123;&#123; currentUser.name &#125;&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> &lt;div ng-if=&quot;isAuthorized(userRoles.admin)&quot;&gt;</span><br><span class="line">  You&apos;re admin.</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> &lt;div ng-switch=&quot;&quot; on=&quot;currentUser.role&quot;&gt;</span><br><span class="line">  &lt;div ng-switch-when=&quot;userRoles.admin&quot;&gt;</span><br><span class="line">   You&apos;re admin.</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div ng-switch-when=&quot;userRoles.editor&quot;&gt;</span><br><span class="line">   You&apos;re editor.</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div ng-switch-default=&quot;&quot;&gt;</span><br><span class="line">   You&apos;re something else.</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="限制路由访问"><a href="#限制路由访问" class="headerlink" title="限制路由访问"></a>限制路由访问</h2><p>很多时候你会想让整个网页都不能被访问，而不是仅仅隐藏一个元素。如果可以再路由（在UI Router 里，路由也叫状态）使用一种自定义的数据结构，我们就可以明确哪些用户角色可以被允许访问哪些内容。下面这个例子使用 UI Router 的风格，但是这些同样适用于 ngRoute。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.config(function($stateProvider, USER_ROLES) &#123;</span><br><span class="line">    $stateProvider.state(&apos;dashboard&apos;, &#123;</span><br><span class="line">        url: &apos;/dashboard&apos;,</span><br><span class="line">        templateUrl: &apos;dashboard/index.html&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            authorizedRoles: [USER_ROLES.admin, USER_ROLES.editor]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>下一步，我们需要检查每次路由变化（就是用户跳转到其他页面的时候）。这需要监听 $routeChangStart（ngRoute 里的）或者 $stateChangeStart（UI Router 里的）事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.run(function($rootScope, AUTH_EVENTS, AuthService) &#123;</span><br><span class="line">    $rootScope.$on(&apos;$stateChangeStart&apos;,</span><br><span class="line">    function(event, next) &#123;</span><br><span class="line">        var authorizedRoles = next.data.authorizedRoles;</span><br><span class="line">        if (!AuthService.isAuthorized(authorizedRoles)) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">            if (AuthService.isAuthenticated()) &#123; </span><br><span class="line">                // user is not allowed        </span><br><span class="line">                $rootScope.$broadcast(AUTH_EVENTS.notAuthorized);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // user is not logged in        </span><br><span class="line">                $rootScope.$broadcast(AUTH_EVENTS.notAuthenticated);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="Session-时效"><a href="#Session-时效" class="headerlink" title="Session 时效"></a>Session 时效</h2><p>身份认证多半是服务器端的事情。无论你用什么实现方式，你的后端会对用户信息做真正的验证和处理诸如 Session 时效和访问控制的处理。这意味着你的 API 会有时返回一些认证错误。标准的错误码就是 HTTP 状态吗。普遍使用这些错误码：</p>
<p>401 Unauthorized — The user is not logged in<br>403 Forbidden — The user is logged in but isn’t allowed access<br>419 Authentication Timeout (non standard) — Session has expired<br>440 Login Timeout (Microsoft only) — Session has expired<br>后两种不是标准内容，但是可能广泛应用。最好的官方的判断 session 过期的错误码是 401。无论怎样，你的登陆对话框都应该在 API 返回 401， 419， 440 或者 403 的时候马上显示出来。总的来说，我们想广播和基于这些 HTTP 返回码的时间，为此我们在 $httpProvider 增加一个拦截器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.config(function($httpProvider) &#123;</span><br><span class="line">    $httpProvider.interceptors.push([&apos;$injector&apos;,</span><br><span class="line">    function($injector) &#123;</span><br><span class="line">        return $injector.get(&apos;AuthInterceptor&apos;);</span><br><span class="line">    &#125;]);</span><br><span class="line">&#125;)</span><br><span class="line">.factory(&apos;AuthInterceptor&apos;,</span><br><span class="line">function($rootScope, $q, AUTH_EVENTS) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        responseError: function(response) &#123;</span><br><span class="line">            $rootScope.$broadcast(&#123;</span><br><span class="line">                401 : AUTH_EVENTS.notAuthenticated,</span><br><span class="line">                403 : AUTH_EVENTS.notAuthorized,</span><br><span class="line">                419 : AUTH_EVENTS.sessionTimeout,</span><br><span class="line">                440 : AUTH_EVENTS.sessionTimeout</span><br><span class="line">            &#125; [response.status], response);</span><br><span class="line">            return $q.reject(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这只是一个认证拦截器的简单实现。有个很棒的项目在 Github ，它做了相同的事情，并且使用了 httpBuffer 服务。当返回 HTTP 错误码时，它会阻止用户进一步的请求，直到用户再次登录，然后继续这个请求。</p>
<h2 id="登录对话框指令"><a href="#登录对话框指令" class="headerlink" title="登录对话框指令"></a>登录对话框指令</h2><p>当一个 session 过期了，我们需要用户重新进入他的账号。为了防止他丢失他当前的工作，最好的方法就是弹出登录登录对话框，而不是跳转到登录页面。这个对话框需要监听 notAuthenticated 和 sessionTimeout 事件，所以当其中一个事件被触发了，对话框就要打开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.directive(&apos;loginDialog&apos;,</span><br><span class="line">function(AUTH_EVENTS) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        restrict: &apos;A&apos;,</span><br><span class="line">        template: &apos;&lt;div ng-if=&quot;visible&quot;  ng-include=&quot;\&apos;login-form.html\&apos;&quot;&gt;&apos;,</span><br><span class="line">        link: function(scope) &#123;</span><br><span class="line">            var showDialog = function() &#123;</span><br><span class="line">                scope.visible = true;</span><br><span class="line">            &#125;;</span><br><span class="line">            scope.visible = false;</span><br><span class="line">            scope.$on(AUTH_EVENTS.notAuthenticated, showDialog);</span><br><span class="line">            scope.$on(AUTH_EVENTS.sessionTimeout, showDialog)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>只要你喜欢，这个对话框可以随便扩展。主要的思想是重用已存在的登陆表单模板和 LoginController。你需要在每个页面写上如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div login-dialog ng-if=&quot;!isLoginPage&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意 isLoginPage 检查。一个失败了的登陆会触发 notAuthenticated 时间，但我们不想在登陆页面显示这个对话框，因为这很多余和奇怪。这就是为什么我们不把登陆对话框也放在登陆页面的原因。所以在 ApplicationController 里定义一个 $scope.isLoginPage 是合理的。</p>
<h2 id="保存用户状态"><a href="#保存用户状态" class="headerlink" title="保存用户状态"></a>保存用户状态</h2><p>在用户刷新他们的页面，依旧保存已登陆的用户信息是单页应用认证里面狡猾的一个环节。因为所有状态都存在客户端，刷新会清空用户信息。为了修复这个问题，我通常实现一个会返回已登陆的当前用户的数据的 API （比如 /profile），这个 API 会在 AngularJS 应用启动（比如在 “run” 函数）。然后用户数据会被保存在 Session 服务或者 $rootScope，就像用户已经登陆后的状态。或者，你可以把用户数据直接嵌入到 index.html，这样就不用额外的请求了。第三种方式就是把用户数据存在 cookie 或者 LocalStorage，但这会使得登出或者清空用户数据变得困难一点。</p>
<p>最后……</p>
<p>鄙人才疏学浅，一点点经验，这是一篇翻译的文章，如有谬误，欢迎指正。</p>
<p>原文章作者：<a href="https://coding.net/u/huangruichang" target="_blank" rel="noopener">huangruichang</a></p>
<p>参考阅读</p>
<p><a href="https://medium.com/opinionated-angularjs/techniques-for-authentication-in-angularjs-applications-7bbf0346acec" target="_blank" rel="noopener">Techniques for authentication in AngularJS applications</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/15/转-AngularJS-应用身份认证的技巧/" data-id="cjbdfjnn200067or30gdgdita" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/angularjs/">angularjs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/02/16/angularjs-学习的那些事儿(2)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          angularjs-学习的那些事儿(2)
        
      </div>
    </a>
  
  
    <a href="/2016/02/15/angularjs-学习的那些事儿(1)/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">angularjs 学习的那些事儿(1)</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术/">前端技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/闲言碎语/">闲言碎语</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/angularjs/">angularjs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/meteor/">meteor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信公众平台/">微信公众平台</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/angularjs/" style="font-size: 20px;">angularjs</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/meteor/" style="font-size: 20px;">meteor</a> <a href="/tags/前端/" style="font-size: 20px;">前端</a> <a href="/tags/微信公众平台/" style="font-size: 10px;">微信公众平台</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/18/2017-12-18-js正则替换图片路径/">js正则替换图片路径</a>
          </li>
        
          <li>
            <a href="/2016/02/24/2016-02-24-【转】git批量删除文件夹和文件/">【转】git批量删除文件夹和文件</a>
          </li>
        
          <li>
            <a href="/2016/02/18/2016-02-18-meteor验证微信公众平台/">meteor验证微信公众平台</a>
          </li>
        
          <li>
            <a href="/2016/02/17/2016-02-17-译-服务端路由选择-Server-Side-Routing-with-Picker/">[译]服务端路由选择---Server Side Routing with Picker</a>
          </li>
        
          <li>
            <a href="/2016/02/16/折腾HEXO的二三事/">折腾HEXO的二三事</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>